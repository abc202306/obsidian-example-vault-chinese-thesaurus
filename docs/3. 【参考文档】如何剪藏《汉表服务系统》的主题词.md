---
ctime: 2025-05-27T15:08:17+08:00
mtime: 2025-11-07T15:38:46+08:00
---

# 3. 【参考文档】如何剪藏《汉表服务系统》的主题词

- related: [[README]]

- 步骤1 - 复制代码：复制下面的 JavaScript 代码片段
- 步骤2 - 保存为代码片段：将复制的内容保存为浏览器的开发者工具的`代码片段`，需要使用 `Ctrl+P` 和键入 `>`  调出命令面板搜索  `创建新的代码片段` 来运行
- 步骤3 - 在需要时运行片段：在[《汉表服务系统网站》](https://ct.istic.ac.cn/site/organize/word)的一个主题词的详细信息页，在需要时使用`Ctrl+P` 和键入 `! ` 来搜索该片段的名称来运行
- 步骤4 - 保存笔记：复制控制台输出的文本，保存为 Markdown 笔记，并且存放到目录 `chinesethesaurus`
- 步骤5 - 整理笔记：创建或整理相关的分类笔记

```js
"use strict";
async function main() {
	const tables = document.querySelectorAll("table.table-bordered");
	const wordTableStrArr = [];
	let title = "";
	let i = 1;
	for (let t of tables){
		let [title01, wordTableStr] = (new DescriptorInfoTable(t)).getWordTableStr(i === 1);
		if (title.length === 0 ) {
			title = title01;
		}
		if (wordTableStr !== ""){
			wordTableStrArr.push(wordTableStr);
		}
		i++;
	}
	i = 1;
	console.log(title);
	let count = wordTableStrArr.length;
	for (let wordTableStr of wordTableStrArr) {
		console.log("=="+i);
		console.log(wordTableStr);
		const options = {
			"file": "chinesethesaurus/"+encodeURIComponent(title),
			"content": encodeURIComponent(wordTableStr),
			"append": "1",
		};
		console.log(options);
		const obsidianURI = "obsidian://new?"+Object.entries(options).map(e=>e[0]+"="+e[1]).join("&");
		console.log("==started",obsidianURI);
		if (confirm("Do you want to proceed? ("+i+"/"+count+")")) {
			window.location.href = obsidianURI;
		}
		i++;
	}
}

function getLocalISOStringWithTimezone() {
    const date = new Date();

    // Helper to pad numbers to two digits
    const pad = (n) => `${Math.floor(Math.abs(n))}`.padStart(2, '0');

    // Get the timezone offset in minutes and determine the sign
    const timezoneOffsetMinutes = date.getTimezoneOffset();
    const offsetSign = timezoneOffsetMinutes > 0 ? '-' : '+'; // getTimezoneOffset is opposite of actual UTC offset
    const offsetHours = Math.floor(Math.abs(timezoneOffsetMinutes) / 60);
    const offsetMinutes = Math.abs(timezoneOffsetMinutes) % 60;
    const timezoneOffsetString = `${offsetSign}${pad(offsetHours)}:${pad(offsetMinutes)}`;

    // Manually build the ISO string
    const localISOString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T` +
                           `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}` +
                           timezoneOffsetString;
                           
    return localISOString;
}


var DescriptorInfoTable = /** @class */ (function () {
    function DescriptorInfoTable(t) {
        this.sources = [];
        this.categories = [];
        this.english = "";
        this.synonyms = [];
        this.broadterms = [];
        this.relatedterms = [];
        this.narrowerterms = [];
        this.aliases = [];
        this.t = t;
    }
    DescriptorInfoTable.prototype.getWordTableStr = function (isFirst) {
        var _this = this;
        this.t.querySelectorAll("tr").forEach(function (tr) {
            var th = tr.querySelector("th");
            var td = tr.querySelector("td");
            if (!th || !td) {
                throw new TypeError("TypeError: ( !th || !td ) === true");
            }
            var thText = th.innerText;
            var tdText = td.innerText;
            var tdItemArr = tdText.split("、");
            if (thText === DescriptorInfoTable.field.sources) {
                _this.sources = tdItemArr;
            }
            else if (thText === DescriptorInfoTable.field.categories) {
                _this.categories = tdText.split(/、(?=[A-Z])/g).map(str=>{
	                const res = /^([a-zA-Z0-9\-\.\*\+\_]+)(.*)/.exec(str.replaceAll("*","_"));
	                return res[1]+" "+res[2];
	            });
            }
            else if (thText === DescriptorInfoTable.field.english) {
                _this.english = tdText;
            }
            else if (thText === DescriptorInfoTable.field.synonyms) {
                _this.synonyms = tdItemArr;
            }
            else if (thText === DescriptorInfoTable.field.broadterms) {
                _this.broadterms = tdItemArr.filter(strItem=>strItem.length!==0);
            }
            else if (thText === DescriptorInfoTable.field.relatedterms) {
                _this.relatedterms = tdItemArr;
            }
            else if (thText === DescriptorInfoTable.field.narrowerterms) {
                _this.narrowerterms = tdItemArr;
            }
            else {
                _this[thText] = tdText;
            }
        });
        if (this.synonyms) {
            this.aliases = Array.from(this.synonyms);
            if (this.english) {
                this.aliases.push(this.english);
            }
        }
        else {
            this.aliases = [this.english];
        }
        if (this.english === "saline water;salt brine;saltwater;salt-water") {
            return ["", ""];
        }
        var orderedKeys = [
            "sources", "categories", "english",
            "synonyms", "broadterms", "narrowerterms", "relatedterms"
        ];
        const title = document.querySelectorAll('.col-md-6>h3')[0].textContent;
        var str1 = "# " + title + "\n";

        var str2 = "| | |\n| --- | --- |\n" + orderedKeys.map(function (key) {
            if (key === "english") {
                return "| " + DescriptorInfoTable.field.english + " | " + _this.english + " |";
            }
            else if (["broadterms", "narrowerterms", "relatedterms", "categories", "sources"].some(function (w) { return w === key; })) {
                //const value02 = (value as string[]).map(w => "[[" + w + "]]").join("、")
                var _a = _this.getEntry(key), key2 = _a.key2, value2 = _a.value2;
                if (value2.length === 0) {
                    return "";
                }
                var value2Str;
                if (key === "categories") {
	                value2Str = value2.map(function (w) { return "[[" + w + " 主题词分类\|" + w + "]]"; }).join("、");
                } else {
	                value2Str = value2.map(function (w) { return "[[" + w + "]]"; }).join("、");
                }
                
                return "| " + key2 + " | " + value2Str + " |";
            }
            else if (["synonyms"].some(function (w) { return w === key; })) {
                var _b = _this.getEntry(key), key2 = _b.key2, value2 = _b.value2;
                if (value2.length === 0) {
                    return "";
                }
                var value2Str = value2.join("、");
                return "| " + key2 + " | " + value2Str + " |";
            }
            return "";
        }).filter(function (s) { return s.length > 0; }).join("\n") + "\n";
        const now = ""+getLocalISOStringWithTimezone();
        var str3 = "---\nup:\n  - \"[[汉语主题词]]\"\n" + orderedKeys.map(function (key) {
            var value = _this[key];
            if (key === "english") {
                var key2 = DescriptorInfoTable.field.english;
                var value2Str = value;
                key2 = "" + key2;
                return  key + ": " + value2Str;
            }
            else if (["broadterms", "narrowerterms", "relatedterms", "categories", "sources"].some(function (w) { return w === key; })) {
                var _a = _this.getEntry(key), key2 = _a.key2, value2 = _a.value2;
                key2 = "" + key2;
                if (value2.length === 0) {
                    return key + ":";
                }
                var value2Str;
                if (key === "categories") {
	                value2Str = value2.map(function (w) { return '  - "[[' + w + " 主题词分类|" + w + ']]"'; }).join("\n");
                } else {
	                value2Str = value2.map(function (w) { return '  - "[[' + w + ']]"'; }).join("\n");
                }
                
                return key + ":\n" + value2Str;
            }
            else if (["synonyms"].some(function (w) { return w === key; })) {
                var _b = _this.getEntry(key), key2 = _b.key2, value2 = _b.value2;
                key2 = "" + key2;
                if (value2.length === 0) {
                    return key + ":";
                }
                var value2Str = value2.map(function (w) { return '  - ' + w + ''; }).join("\n");
                return key + ":\n" + value2Str;
            }
        }).join("\n") + "\n" + "aliases:\n" + this.aliases.map(function (w) { return '  - ' + w + ''; }).join("\n") + "\n"+"ctime: "+now+"\n"+"mtime: "+now+"\n"+"---\n";
        let arr;
        if (isFirst){
	        arr = [str3, str1, str2];
        } else {
	        arr = [str3, str2];
        }
        const wordTableStr = arr.join("\n");
        return [title, wordTableStr];
    };
    DescriptorInfoTable.prototype.getEntry = function (key) {
        var key2;
        var value2 = "";
        if (key === "broadterms") {
            key2 = DescriptorInfoTable.field.broadterms;
            value2 = this.broadterms;
        }
        else if (key === "narrowerterms") {
            key2 = DescriptorInfoTable.field.narrowerterms;
            value2 = this.narrowerterms;
        }
        else if (key === "relatedterms") {
            key2 = DescriptorInfoTable.field.relatedterms;
            value2 = this.relatedterms;
        }
        else if (key === "sources") {
            key2 = DescriptorInfoTable.field.sources;
            value2 = this.sources;
        }
        else if (key === "synonyms") {
            key2 = DescriptorInfoTable.field.synonyms;
            value2 = this.synonyms;
        }
        else if (key === "categories") {
            key2 = DescriptorInfoTable.field.categories;
            value2 = this.categories;
        }
        else {
            throw new Error("Unknown key: ".concat(key));
        }
        return { key2: key2, value2: value2 };
    };
    DescriptorInfoTable.field = {
        sources: "来源", // String Array
        english: "英文", // String | prop 03
        synonyms: "同义词", // String Array | prop 05
        broadterms: "上位词", // Link Array | prop 06
        narrowerterms: "下位词", // Link Array | prop 07
        relatedterms: "相关词", // Link Array | prop 08
        categories: "分类" // Link Array | prop 31
    };
    return DescriptorInfoTable;
}());

main();

```
