
- [[#配置]]
- [[#主题词]]
- [[#主题词分类表]]
- [[#主题词组配分类表]]

## 配置

> 修改配置以指定文件夹路径

- 主题词 - 文件夹路径:: data/82 汉语主题词表/主题词
- 主题词分类表 - 文件夹路径:: data/82 汉语主题词表/主题词分类表
- 主题词组配分类表 - 文件夹路径:: data/82 汉语主题词表/主题词组配分类表

## 主题词

> 参见 [[82 汉语主题词表]]

```dataviewjs

const descriptorPath = dv.current()["主题词 - 文件夹路径"];

/** @function */
const getGroupKey = await new Promise(resolve => dv.view("dvmodule/get-group-key", resolve))

const headers = [
	"File",
	"03 英文",
	"05 同义词",
	"06 上位词",
	"07 下位词",
	"08 相关词",
	"31 分类",
	"来源",
	"file.cday"
];

const fieldMap = {
	english: "主题词-英文",
	synonyms: "主题词-同义词",
	broadTerms: "主题词-上位词",
	narrowerTerms: "主题词-下位词",
	relatedTerms: "主题词-相关词",
	classifications: "主题词-分类",
	sources: "主题词-来源"
}

const regexMap = {
	excluding: {
		fileName: /(^.*\/)|(\.md$)/g,
		descriptorClassificationFileName: /(^.*\/)|(\s主题词表\.md$)/g
	}
}

const markerMap = {
	resolvedLink: {
		descriptor: "🟢",
		descriptorClassification: "📗"
	}
}

class LinkRenderUtil {
	static getDescriptorResolvedLink(l){
		return dv.func.link(
			l.path,
			markerMap.resolvedLink.descriptor+l.path.replace(
				regexMap.excluding.fileName,
				""
			)
		)
	}
	static getDescriptorClassificationResolvedLink(l){
		return dv.func.link(
			l.path,
			markerMap.resolvedLink.descriptorClassification+l.path.replace(
				regexMap.excluding.descriptorClassificationFileName,
				""
			)
		)
	}
}

class ArrayUtil {
	static maxLenLinkArr = 3;
	static clipArr(arr){
		if(arr.length<=this.maxLenLinkArr){
			return arr;
		}
		return [
			...arr.slice(0, this.maxLenLinkArr), 
			"..."
		];
	}
	static isLinkResolvedInFolder(link){
		return dv.func.contains(link.path, "/");
	}
	static getDescriptorItemLinkArr(linkArr){
		return linkArr
			.filter(l=>this.isLinkResolvedInFolder(l))
			.map(l=>LinkRenderUtil.getDescriptorResolvedLink(l)).concat(linkArr
				.filter(l=>!this.isLinkResolvedInFolder(l))
			);
	}
}

class PageProxy {
	#p;
	
	constructor(p){this.#p=p;}
	static get(p){return new this(p)}
	
	getFileLink(){
		return LinkRenderUtil.getDescriptorResolvedLink(this.#p.file.link)
	}
	getEnglish(){
		return this.#p[fieldMap.english];
	}
	getSynonyms(){
		return ArrayUtil.clipArr(
			this.#p[fieldMap.synonyms] || []
		)
	}
	getBroadTerms(){
		return (this.#p[fieldMap.broadTerms] || []).map(l=>
			LinkRenderUtil.getDescriptorResolvedLink(l)
		)
	}
	getNarrowerTerms(){
		return ArrayUtil.clipArr(
			ArrayUtil.getDescriptorItemLinkArr(
				this.#p[fieldMap.narrowerTerms] || []
			)
		)
	}
	getRelatedTerms(){
		return ArrayUtil.clipArr(
			ArrayUtil.getDescriptorItemLinkArr(
				this.#p[fieldMap.relatedTerms] || []
			)
		)
	}
	getClassifications(){
		return (this.#p[fieldMap.classifications] || []).map(l=>
			LinkRenderUtil.getDescriptorClassificationResolvedLink(l)
		)
	}
	getSources(){
		return this.#p[fieldMap.sources] || []
	}
	getCDay(){
		return this.#p.file.cday;
	}

	getElem(){
		return [
			this.getFileLink(),
			this.getEnglish(),
			this.getSynonyms(),
			this.getBroadTerms(),
			this.getNarrowerTerms(),
			this.getRelatedTerms(),
			this.getClassifications(),
			this.getSources(),
			this.getCDay()
		]
	}
}

function getScrollableDiv(container){
	return container.createDiv({attr:{style:"overflow:scroll;"}});
}

function show(){
	dv.container.style.overflowX = "visible";

	const groups = dv
		.pages(`"${descriptorPath}"`)
		.sort(p=>p.file.ctime, "desc")
		.groupBy(p=>getGroupKey(p))
		.sort(g=>g.rows[0].file.ctime, "desc");
	
	groups.forEach(g=>{
		dv.header(4, g.key)
		dv.api.table(
			headers, 
			g.rows.map(p=>PageProxy.get(p).getElem()),
			getScrollableDiv(dv.container),
			dv.component,
			dv.currentFilePath
		)
	});
}

show()

```

## 主题词分类表

> 参见 [[1 中国图书馆分类法]]

```dataviewjs


const descriptorPath = dv.current()["主题词 - 文件夹路径"];
const descriptorClsPath = dv.current()["主题词分类表 - 文件夹路径"]
const assemblyDescriptorClsPath = dv.current()["主题词组配分类表 - 文件夹路径"]

/** @function */
const getGroupKey = await new Promise(resolve => dv.view("dvmodule/get-group-key", resolve))

/** @function */
const getDCDescriptors = await new Promise(resolve => dv.view("dvmodule/get-dc-descriptors", resolve))

const headers = [
	"File",
	"主题词",
	"下位主题词表",
	"file.cday"
]

const fieldMap = {
	narrowerClses: "主题词表-下位主题词表"
}

const regexMap = {
	excluding: {
		descriptorClsFileName: /(^.*\/)|(主题词表\.md$)/g,
		assemblyDescriptorClsFileName: /(.*\/)|(组配 主题词表\.md$)/g
	}
}

const markerMap = {
	resolvedLink: {
		descriptorClassification: "📗"
	}
}

function getNarrowerDCls(p){
	return (p[fieldMap.narrowerClses]||[])
		.map(l=>dv.func.link(
				l.path,
				markerMap.resolvedLink.descriptorClassification+l.path.replace(regexMap.excluding.assemblyDescriptorClsFileName,"")
			))
}

function getElem(p){
	return [
		dv.func.link(p.file.path,markerMap.resolvedLink.descriptorClassification+p.file.path.replace(regexMap.excluding.descriptorClsFileName,"")),
		getDCDescriptors(p, descriptorPath),
		getNarrowerDCls(p),
		p.file.cday
	]
}

dv.container.style.overflowX = "visible";

dv.pages(`"${descriptorClsPath}"`)
	.sort(p=>p.file.ctime, "desc")
	.groupBy(p=>getGroupKey(p))
	.sort(g=>g.rows[0].file.ctime, "desc")
	.forEach(g=>{
		dv.header(4, g.key);
		dv.api.table(
			headers, 
			g.rows.map(p=>getElem(p)), 
			dv.container.createDiv({attr:{style:"overflow:scroll"}}),
			dv.component,
			dv.currentFilePath
		)
	})

```


## 主题词组配分类表

> 参见 [[1 中国图书馆分类法]]

```dataviewjs


const descriptorPath = dv.current()["主题词 - 文件夹路径"];
const descriptorClsPath = dv.current()["主题词分类表 - 文件夹路径"]
const assemblyDescriptorClsPath = dv.current()["主题词组配分类表 - 文件夹路径"]

/** @function */
const getGroupKey = await new Promise(resolve => dv.view("dvmodule/get-group-key", resolve))

/** @function */
const getDCDescriptors = await new Promise(resolve => dv.view("dvmodule/get-dc-descriptors", resolve))

const headers = [
	"File",
	"主题词",
	"上位主题词表",
	"file.cday"
]

const fieldMap = {
	broadClses: "主题词表-上位主题词表"
}

const regexMap = {
	excluding: {
		descriptorClsFileName: /(^.*\/)|(主题词表\.md$)/g,
		assemblyDescriptorClsFileName: /(.*\/)|(组配 主题词表\.md$)/g
	}
}

const markerMap = {
	resolvedLink: {
		descriptorClassification: "📗"
	}
}

function getBroadDCls(p){
	return (p[fieldMap.broadClses]||[])
		.map(l=>dv.func.link(
				l.path,
				markerMap.resolvedLink.descriptorClassification+l.path.replace(regexMap.excluding.descriptorClsFileName,"")
			))
}

function getElem(p){
	return [
		dv.func.link(p.file.path,markerMap.resolvedLink.descriptorClassification+p.file.path.replace(regexMap.excluding.assemblyDescriptorClsFileName,"")),
		getDCDescriptors(p, descriptorPath),
		getBroadDCls(p),
		p.file.cday
	]
}

dv.container.style.overflowX = "visible";

dv.pages(`"${assemblyDescriptorClsPath}"`)
	.sort(p=>p.file.ctime, "desc")
	.groupBy(p=>getGroupKey(p))
	.sort(g=>g.rows[0].file.ctime, "desc")
	.forEach(g=>{
		dv.header(4, g.key);
		dv.api.table(
			headers, 
			g.rows.map(p=>getElem(p)), 
			dv.container.createDiv({attr:{style:"overflow:scroll"}}),
			dv.component,
			dv.currentFilePath
		)
	})

```
